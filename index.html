<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping Test</title>
    <style>
        /* Container for grid layout */
        #ping-results {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Four equal columns */
            gap: 20px; /* Add some space between the columns */
            padding: 20px;
        }

        /* Styling for each server section */
        .server-section {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            background-color: #f9f9f9;
        }

        h2 {
            text-align: center;
            font-size: 18px;
            margin-bottom: 10px;
        }

        ul {
            list-style-type: none;
            padding-left: 0;
            max-height: 200px; /* Max height to prevent overflow */
            overflow-y: auto;  /* Scroll if list gets too long */
        }

        ul li {
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
        }

        p {
            font-weight: bold;
            text-align: center;
            margin-top: 10px; /* Ensure margin to separate from list */
        }

        /* Explanation section */
        #explanation {
            margin: 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #f5f5f5;
            text-align: center;
        }

        /* Export button styling */
        #export-btn {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: not-allowed;
            opacity: 0.5;
            position: relative;
        }

        /* Tooltip container */
        #export-btn:hover::after {
            content: attr(data-hover);
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            visibility: hidden;
        }

        /* Show tooltip when hovered */
        #export-btn:hover:enabled::after {
            visibility: hidden;
        }

        #export-btn:hover:disabled::after {
            visibility: visible;
            opacity: 1;
        }

        #export-btn:enabled {
            cursor: pointer;
            opacity: 1;
        }
    </style>
</head>
<body>
    <h1>Ping Test Results</h1>

    <!-- Explanation Section -->
    <div id="explanation">
        <h3>Why are we doing this?</h3>
        <p>
            We are conducting this test to determine the best location to host our FiveM server for optimal performance.
            By measuring your connection to different server regions (Chicago, Dallas, Miami, and New York), we can determine which location offers the lowest latency.
        </p>
        <p>
            All data collected is confidential and secure. No private information is collected or stored; only non-identifiable information such as your connection speed to these servers is used.
        </p>
    </div>

    <p id="location-info">Detecting your location...</p>
    <div id="ping-results"></div>
    <button id="export-btn" data-hover="You need 600 pings to enable export" disabled>Export Pings to JSON</button>

    <script>
        let userLocation = '';
        let userLat = '';
        let userLon = '';

        // Servers and their coordinates for distance calculation
        const servers = {
            'Chicago': { url: 'http://ping.chi.scdb.gg', lat: 41.8781, lon: -87.6298, pings: [] },
            'Dallas': { url: 'http://ping.dal.scdb.gg', lat: 32.7767, lon: -96.7970, pings: [] },
            'Miami': { url: 'http://ping.mia.scdb.gg', lat: 25.7617, lon: -80.1918, pings: [] },
            'New York': { url: 'http://ping.nyc.scdb.gg', lat: 40.7128, lon: -74.0060, pings: [] }
        };

        const resultsElement = document.getElementById('ping-results');
        const exportBtn = document.getElementById('export-btn');
        const totalPings = 600;

        // Initialize results storage and display containers for each server
        for (const name in servers) {
            createServerSection(name);
        }

        // Function to create a section for each server
        function createServerSection(name) {
            const section = document.createElement('div');
            section.classList.add('server-section'); // Add class for styling

            const header = document.createElement('h2');
            header.textContent = `${name} Ping Results`;

            const average = document.createElement('p');
            average.id = `average-${name}`;
            average.textContent = `Average: calculating...`;

            const distance = document.createElement('p');
            distance.id = `distance-${name}`;
            distance.textContent = `Distance: calculating...`;

            const list = document.createElement('ul');
            list.id = `ping-list-${name}`;

            section.appendChild(header);
            section.appendChild(average); // Average is below the header but above the list
            section.appendChild(distance); // Distance below the average
            section.appendChild(list);

            resultsElement.appendChild(section);
        }

        // Function to ping a server using HTTP
        async function pingServerHTTP(name, url) {
            const startTime = Date.now(); // Record the time before the request
            try {
                const response = await fetch(url, { method: 'GET', mode: 'cors' });
                if (response.ok) {
                    const endTime = Date.now(); // Record the time after the response is received
                    const ping = endTime - startTime; // Calculate the time difference (ping)
                    servers[name].pings.push(ping); // Store the ping result
                    if (servers[name].pings.length > totalPings) servers[name].pings.shift(); // Keep only the last 600 pings
                    updateResults(name); // Update the results in real-time

                    checkExportAvailability(); // Check if export should be enabled
                } else {
                    appendPing(name, 'Failed to ping');
                }
            } catch (error) {
                appendPing(name, 'Failed to ping');
            }
        }

        // Function to calculate the average ping for a server after removing outliers
        function calculateAverageWithoutOutliers(pings) {
            if (pings.length <= 2) return pings.length > 0 ? pings[0] : 0; // If only 1-2 pings, return the raw average

            // Sort the pings
            const sortedPings = [...pings].sort((a, b) => a - b);

            // Remove the top 10% and bottom 10% (for 600 values, this is the top and bottom 60)
            const trimCount = Math.floor(sortedPings.length * 0.1); // 10% trimming
            const trimmedPings = sortedPings.slice(trimCount, sortedPings.length - trimCount);

            // Calculate the average of the remaining pings
            const sum = trimmedPings.reduce((a, b) => a + b, 0);
            return (sum / trimmedPings.length).toFixed(2);
        }

        // Function to update the displayed results
        function updateResults(name) {
            const pings = servers[name].pings;
            const averagePing = calculateAverageWithoutOutliers(pings);
            const list = document.getElementById(`ping-list-${name}`);
            const average = document.getElementById(`average-${name}`);

            // Update the average display
            average.textContent = `Average (without outliers): ${averagePing} ms (Last ${pings.length} pings)`;

            // Clear and re-populate the list only when new pings are added
            if (pings.length > 0) {
                const newPing = pings[pings.length - 1];
                appendPing(name, `${pings.length}: ${newPing} ms`);
            }
        }

        // Function to append a single ping result to the list without clearing
        function appendPing(name, pingText) {
            const list = document.getElementById(`ping-list-${name}`);
            const li = document.createElement('li');
            li.textContent = pingText;
            list.appendChild(li);
        }

        // Check if we can enable the export button (only when all servers have 600 pings)
        function checkExportAvailability() {
            const allServersReachedLimit = Object.values(servers).every(server => server.pings.length >= totalPings);
            if (allServersReachedLimit) {
                exportBtn.disabled = false;
                exportBtn.style.cursor = 'pointer';
            }
        }

        // Function to export pings and location data to a JSON file
        function exportToJson() {
            const exportData = {
                location: userLocation,
                servers: {}
            };

            // Add ping data for each server
            for (const [name, server] of Object.entries(servers)) {
                exportData.servers[name] = {
                    distance: document.getElementById(`distance-${name}`).textContent,
                    pings: server.pings
                };
            }

            const jsonString = JSON.stringify(exportData, null, 2); // Pretty-print the JSON
            const blob = new Blob([jsonString], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'pings.json';
            link.click();
        }

        // Function to calculate the distance between two lat/lon pairs using the Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3958.8; // Radius of the Earth in miles
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;
            return distance.toFixed(2);
        }

        // Function to get user's location via IP and calculate distances to server regions
        async function getLocationAndCalculateDistances() {
            try {
                const response = await fetch('http://ip-api.com/json'); // IP-based location API
                const data = await response.json();
                
                if (data.status === 'success') {
                    userLat = data.lat;
                    userLon = data.lon;
                    userLocation = `${data.regionName}, ${data.country}`; // Only show state/region and country
                    
                    document.getElementById('location-info').textContent = `Your location: ${userLocation}`;

                    for (const [name, server] of Object.entries(servers)) {
                        const distance = calculateDistance(userLat, userLon, server.lat, server.lon);
                        document.getElementById(`distance-${name}`).textContent = `Distance: ${distance} miles`;
                    }
                } else {
                    document.getElementById('location-info').textContent = 'Unable to retrieve location.';
                }
            } catch (error) {
                document.getElementById('location-info').textContent = 'Error fetching location.';
            }
        }

        // Ping each server every 5 seconds, but with a 1-second delay between servers
        async function startPinging() {
            let delay = 0;
            for (const [name, server] of Object.entries(servers)) {
                setInterval(() => pingServerHTTP(name, server.url), 5000 + delay);
                delay += 1000; // Add 1-second delay between each server's requests
            }
        }

        // Start the IP-based geolocation and ping process
        getLocationAndCalculateDistances();
        startPinging(); // Start the pinging process

        // Set up the export button
        exportBtn.addEventListener('click', exportToJson);
    </script>
</body>
</html>
